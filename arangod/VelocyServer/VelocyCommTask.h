////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2016 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
///
/// @author Aalekh Nigam
////////////////////////////////////////////////////////////////////////////////

#ifndef ARANGOD_VELOCY_SERVER_VELOCY_COMM_TASK_H
#define ARANGOD_VELOCY_SERVER_VELOCY_COMM_TASK_H 1

#include "Scheduler/SocketTask.h"

#include "Basics/Mutex.h"
#include "HttpServer/ArangoTask.h"
#include "Basics/StringBuffer.h"
#include "Basics/WorkItem.h"

#include <deque>
#include <vector>
#include <map>

namespace arangodb {
namespace rest {
class VelocyCommTask;
class VelocyHandler;
class GeneralRequest;
class GeneralResponse;
class GeneralServer;
class VelocyServerJob;


////////////////////////////////////////////////////////////////////////////////
/// @brief velocystream communication
////////////////////////////////////////////////////////////////////////////////

class VelocyCommTask : public ArangoTask {
  VelocyCommTask(VelocyCommTask const&) = delete;
  VelocyCommTask const& operator=(VelocyCommTask const&) = delete;

  
 public:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief constructs a new task
  //////////////////////////////////////////////////////////////////////////////

  VelocyCommTask(GeneralServer*, TRI_socket_t, const ConnectionInfo&,
               double keepAliveTimeout);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief destructs a task
  //////////////////////////////////////////////////////////////////////////////

 protected:
  ~VelocyCommTask();

  
 public:

  //////////////////////////////////////////////////////////////////////////////
  /// @brief reads data from the socket
  //////////////////////////////////////////////////////////////////////////////

  bool processRead();

  protected:

  //////////////////////////////////////////////////////////////////////////////
  /// @brief reads data from the socket
  //////////////////////////////////////////////////////////////////////////////

  void addResponse(GeneralResponse*);

  //////////////////////////////////////////////////////////////////////////////
  /// check the content-length header of a request and fail it is broken
  //////////////////////////////////////////////////////////////////////////////
  // @ TODO: Add checkContentLength support here
  // bool checkContentLength(bool expectContentLength);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief handles CORS options
  //////////////////////////////////////////////////////////////////////////////

  void processCorsOptions(uint32_t compatibility);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief processes a request
  //////////////////////////////////////////////////////////////////////////////

  void processRequest(uint32_t compatibility);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief get request compatibility
  //////////////////////////////////////////////////////////////////////////////

  int32_t getCompatibility() const;

  bool handleRead();
  
  //////////////////////////////////////////////////////////////////////////////
  /// @brief to check whether the recieved packet(s) is header (VStream)
  //////////////////////////////////////////////////////////////////////////////

  bool _isFirstChunk;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief  map number of packet's with a given message id
  //////////////////////////////////////////////////////////////////////////////
  
  std::map<uint32_t, int> messageCount;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief map the message received for a given message id with string message
  //////////////////////////////////////////////////////////////////////////////

  std::map<uint32_t, std::string> vpackMapBody;

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief map the message received for a given message id with Builder Messages corresponding to velocypack
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////

  std::map<uint32_t, velocypack::Builder> vpackMapHeader;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VelocyStream Structure
  //////////////////////////////////////////////////////////////////////////////

  struct velocystream{
    uint32_t length;
    uint32_t chunkx; // chunkx = chunk + isFirstChunk
    uint64_t messageId;
    uint64_t messageLength;
    std::vector<velocypack::Builder> vpacks; // Collection of all Velocypacks
  };

  //////////////////////////////////////////////////////////////////////////////
  /// @brief For carrying header into velocystream request
  //////////////////////////////////////////////////////////////////////////////

  velocypack::Builder _header;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief For carrying velocystream body
  //////////////////////////////////////////////////////////////////////////////

  std::string _body;

  uint64_t message_id;

};
}
}

#endif


